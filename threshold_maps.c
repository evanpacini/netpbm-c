#include "threshold_maps.h"

#include <stdio.h>
#include <stdlib.h>

// clang-format off
// Threshold maps

// 2x2 Bayer matrix
const double kBayer2X2Data[2][2] = {
    {0.0 / 4.0, 2.0 / 4.0},
    {3.0 / 4.0, 1.0 / 4.0}
};
const ThresholdMap kBayer2X2 = {2, 2, (double *)kBayer2X2Data};

// 4x4 Bayer matrix
const double kBayer4X4Data[4][4] = {
    {00.0 / 16.0, 08.0 / 16.0, 02.0 / 16.0, 10.0 / 16.0},
    {12.0 / 16.0, 04.0 / 16.0, 14.0 / 16.0, 06.0 / 16.0},
    {03.0 / 16.0, 11.0 / 16.0, 01.0 / 16.0, 09.0 / 16.0},
    {15.0 / 16.0, 07.0 / 16.0, 13.0 / 16.0, 05.0 / 16.0}
};
const ThresholdMap kBayer4X4 = {4, 4, (double *)kBayer4X4Data};

// 8x8 Bayer matrix
const double kBayer8X8Data[8][8] = {
    {00.0 / 64.0, 32.0 / 64.0, 08.0 / 64.0, 40.0 / 64.0, 02.0 / 64.0,34.0 / 64.0, 10.0 / 64.0, 42.0 / 64.0},
    {48.0 / 64.0, 16.0 / 64.0, 56.0 / 64.0, 24.0 / 64.0, 50.0 / 64.0,18.0 / 64.0, 58.0 / 64.0, 26.0 / 64.0},
    {12.0 / 64.0, 44.0 / 64.0, 04.0 / 64.0, 36.0 / 64.0, 14.0 / 64.0,46.0 / 64.0, 06.0 / 64.0, 38.0 / 64.0},
    {60.0 / 64.0, 28.0 / 64.0, 52.0 / 64.0, 20.0 / 64.0, 62.0 / 64.0,30.0 / 64.0, 54.0 / 64.0, 22.0 / 64.0},
    {03.0 / 64.0, 35.0 / 64.0, 11.0 / 64.0, 43.0 / 64.0, 01.0 / 64.0,33.0 / 64.0, 09.0 / 64.0, 41.0 / 64.0},
    {51.0 / 64.0, 19.0 / 64.0, 59.0 / 64.0, 27.0 / 64.0, 49.0 / 64.0,17.0 / 64.0, 57.0 / 64.0, 25.0 / 64.0},
    {15.0 / 64.0, 47.0 / 64.0, 07.0 / 64.0, 39.0 / 64.0, 13.0 / 64.0,45.0 / 64.0, 05.0 / 64.0, 37.0 / 64.0},
    {63.0 / 64.0, 31.0 / 64.0, 55.0 / 64.0, 23.0 / 64.0, 61.0 / 64.0,29.0 / 64.0, 53.0 / 64.0, 21.0 / 64.0}
};
const ThresholdMap kBayer8X8 = {8, 8, (double *)kBayer8X8Data};

// 16x16 Bayer matrix
const double kBayer16X16Data[16][16] = {
    {000.0 / 256.0, 128.0 / 256.0, 032.0 / 256.0, 160.0 / 256.0, 008.0 / 256.0, 136.0 / 256.0, 040.0 / 256.0, 168.0 / 256.0, 002.0 / 256.0, 130.0 / 256.0, 034.0 / 256.0, 162.0 / 256.0, 010.0 / 256.0, 138.0 / 256.0, 042.0 / 256.0, 170.0 / 256.0},
    {192.0 / 256.0, 064.0 / 256.0, 224.0 / 256.0, 096.0 / 256.0, 200.0 / 256.0, 072.0 / 256.0, 232.0 / 256.0, 104.0 / 256.0, 194.0 / 256.0, 066.0 / 256.0, 226.0 / 256.0, 098.0 / 256.0, 202.0 / 256.0, 074.0 / 256.0, 234.0 / 256.0, 106.0 / 256.0},
    {048.0 / 256.0, 176.0 / 256.0, 016.0 / 256.0, 144.0 / 256.0, 056.0 / 256.0, 184.0 / 256.0, 024.0 / 256.0, 152.0 / 256.0, 050.0 / 256.0, 178.0 / 256.0, 018.0 / 256.0, 146.0 / 256.0, 058.0 / 256.0, 186.0 / 256.0, 026.0 / 256.0, 154.0 / 256.0},
    {240.0 / 256.0, 112.0 / 256.0, 208.0 / 256.0, 080.0 / 256.0, 248.0 / 256.0, 120.0 / 256.0, 216.0 / 256.0, 088.0 / 256.0, 242.0 / 256.0, 114.0 / 256.0, 210.0 / 256.0, 082.0 / 256.0, 250.0 / 256.0, 122.0 / 256.0, 218.0 / 256.0, 090.0 / 256.0},
    {012.0 / 256.0, 140.0 / 256.0, 044.0 / 256.0, 172.0 / 256.0, 004.0 / 256.0, 132.0 / 256.0, 036.0 / 256.0, 164.0 / 256.0, 014.0 / 256.0, 142.0 / 256.0, 046.0 / 256.0, 174.0 / 256.0, 006.0 / 256.0, 134.0 / 256.0, 038.0 / 256.0, 166.0 / 256.0},
    {204.0 / 256.0, 076.0 / 256.0, 236.0 / 256.0, 108.0 / 256.0, 196.0 / 256.0, 068.0 / 256.0, 228.0 / 256.0, 100.0 / 256.0, 206.0 / 256.0, 078.0 / 256.0, 238.0 / 256.0, 110.0 / 256.0, 198.0 / 256.0, 070.0 / 256.0, 230.0 / 256.0, 102.0 / 256.0},
    {060.0 / 256.0, 188.0 / 256.0, 028.0 / 256.0, 156.0 / 256.0, 052.0 / 256.0, 180.0 / 256.0, 020.0 / 256.0, 148.0 / 256.0, 062.0 / 256.0, 190.0 / 256.0, 030.0 / 256.0, 158.0 / 256.0, 054.0 / 256.0, 182.0 / 256.0, 022.0 / 256.0, 150.0 / 256.0},
    {252.0 / 256.0, 124.0 / 256.0, 220.0 / 256.0, 092.0 / 256.0, 244.0 / 256.0, 116.0 / 256.0, 212.0 / 256.0, 084.0 / 256.0, 254.0 / 256.0, 126.0 / 256.0, 222.0 / 256.0, 094.0 / 256.0, 246.0 / 256.0, 118.0 / 256.0, 214.0 / 256.0, 086.0 / 256.0},
    {003.0 / 256.0, 131.0 / 256.0, 035.0 / 256.0, 163.0 / 256.0, 011.0 / 256.0, 139.0 / 256.0, 043.0 / 256.0, 171.0 / 256.0, 001.0 / 256.0, 129.0 / 256.0, 033.0 / 256.0, 161.0 / 256.0, 009.0 / 256.0, 137.0 / 256.0, 041.0 / 256.0, 169.0 / 256.0},
    {195.0 / 256.0, 067.0 / 256.0, 227.0 / 256.0, 099.0 / 256.0, 203.0 / 256.0, 075.0 / 256.0, 235.0 / 256.0, 107.0 / 256.0, 193.0 / 256.0, 065.0 / 256.0, 225.0 / 256.0, 097.0 / 256.0, 201.0 / 256.0, 073.0 / 256.0, 233.0 / 256.0, 105.0 / 256.0},
    {051.0 / 256.0, 179.0 / 256.0, 019.0 / 256.0, 147.0 / 256.0, 059.0 / 256.0, 187.0 / 256.0, 027.0 / 256.0, 155.0 / 256.0, 049.0 / 256.0, 177.0 / 256.0, 017.0 / 256.0, 145.0 / 256.0, 057.0 / 256.0, 185.0 / 256.0, 025.0 / 256.0, 153.0 / 256.0},
    {243.0 / 256.0, 115.0 / 256.0, 211.0 / 256.0, 083.0 / 256.0, 251.0 / 256.0, 123.0 / 256.0, 219.0 / 256.0, 091.0 / 256.0, 241.0 / 256.0, 113.0 / 256.0, 209.0 / 256.0, 081.0 / 256.0, 249.0 / 256.0, 121.0 / 256.0, 217.0 / 256.0, 089.0 / 256.0},
    {015.0 / 256.0, 143.0 / 256.0, 047.0 / 256.0, 175.0 / 256.0, 007.0 / 256.0, 135.0 / 256.0, 039.0 / 256.0, 167.0 / 256.0, 013.0 / 256.0, 141.0 / 256.0, 045.0 / 256.0, 173.0 / 256.0, 005.0 / 256.0, 133.0 / 256.0, 037.0 / 256.0, 165.0 / 256.0},
    {207.0 / 256.0, 079.0 / 256.0, 239.0 / 256.0, 111.0 / 256.0, 199.0 / 256.0, 071.0 / 256.0, 231.0 / 256.0, 103.0 / 256.0, 205.0 / 256.0, 077.0 / 256.0, 237.0 / 256.0, 109.0 / 256.0, 197.0 / 256.0, 069.0 / 256.0, 229.0 / 256.0, 101.0 / 256.0},
    {063.0 / 256.0, 191.0 / 256.0, 031.0 / 256.0, 159.0 / 256.0, 055.0 / 256.0, 183.0 / 256.0, 023.0 / 256.0, 151.0 / 256.0, 061.0 / 256.0, 189.0 / 256.0, 029.0 / 256.0, 157.0 / 256.0, 053.0 / 256.0, 181.0 / 256.0, 021.0 / 256.0, 149.0 / 256.0},
    {255.0 / 256.0, 127.0 / 256.0, 223.0 / 256.0, 095.0 / 256.0, 247.0 / 256.0, 119.0 / 256.0, 215.0 / 256.0, 087.0 / 256.0, 253.0 / 256.0, 125.0 / 256.0, 221.0 / 256.0, 093.0 / 256.0, 245.0 / 256.0, 117.0 / 256.0, 213.0 / 256.0, 085.0 / 256.0}
};
const ThresholdMap kBayer16X16 = {16, 16, (double *)kBayer16X16Data};
// clang-format on

/**
 * Allocate memory for a threshold map.
 *
 * @param width     The width of the map.
 * @param height    The height of the map.
 * @return          A pointer to the ThresholdMap, or NULL if an error occurred.
 */
ThresholdMap *AllocateThresholdMap(uint32_t width, uint32_t height) {
  ThresholdMap *map = (ThresholdMap *)malloc(sizeof(ThresholdMap));
  if (!map) {
    fprintf(stderr, "Error: out of memory\n");
    return NULL;
  }
  map->width_  = width;
  map->height_ = height;
  map->data_   = (double *)calloc(width * height, sizeof(double));
  if (!map->data_) {
    fprintf(stderr, "Error: out of memory\n");
    free(map);
    return NULL;
  }
  return map;
}

/**
 * Convert a PGM image to a threshold map.
 *
 * @param pgm   The PGM image to convert.
 * @return      A pointer to the ThresholdMap, or NULL if an error occurred.
 */
ThresholdMap *PgmToThresholdMap(PgmImage *pgm) {
  ThresholdMap *map = AllocateThresholdMap(pgm->width_, pgm->height_);
  if (!map) {
    return NULL;
  }
  // Convert the PGM values to doubles in the range [0, 1].
#pragma omp parallel for default(none) shared(map, pgm)
  for (uint64_t i = 0; i < pgm->width_ * pgm->height_; i++)
    map->data_[i] = (double)pgm->data_[i] / 255.0;
  return map;
}

/**
 * Free the memory used by a threshold map.
 *
 * @param map   The map to free.
 */
void FreeThresholdMap(ThresholdMap *map) {
  free(map->data_);
  free(map);
}
